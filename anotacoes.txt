1- Dependencias gradle
	Spring WEB (Criação do server e API)
	MongoDB embeded (Persistencia de dados)
	MongoDB  (Persistencia de dados)

Vamos fazer um crud, aquele que contem as 4 operações em relação a BD numa operação de um aplicativo, sendo eles: Create, Read, Update e Delete, vamos fazer cada um dele com um metodo de API seguindo a mesma ordem: POST, GET, PUT e DELETE e cada um com sua rota nominal, sem ter que ser a mesma rota com parametros diferentes.
Assim que criado e aberto o projeto ele já pode ser executao e acessado via postman. Ainda no postman criamos toda a documentação, fazendo um pacote.

Criamos nossa classe de dominio/modelo de classe e assim nasceu Account que será um data class, que é basicamente uma classe, mas que guarda dados e se necessário metodos sobre a classe criado, os dados são passados via parametro e dali já saem automaticamente getters e setters e construtores.
Nessa data class criamos somente os dados no parenteses, sendo alguns nullables.
Criamos então uma interface para ser o retpository e extendenmos o MongoRepository nela onde na extenção passamos a classe modelo (Account) e o tipo do atributo ID (String), após isso criamos uma função que faz a busca pelo documento, isso é: documento é parametro dessa função, função essa que retorna um Optional do tipo Account, já que vamos buscar uma conta
Vamos criar o controller que irá controlar nossas requisições, anotamos com @RestController para mostrar que essa class é a class de controller e anotamos com @ResquestMapping para passar como parametro o endoint. Após isso anotamos com @PostMapping e criamos a função do POST para criação de acconts ("/accounts") como parametro da fun colocamos a anotação @RequestBody e passamos o esperado, no caso um account do tipo Account, com essa anotação o Spring saberá fazer o parse do json para a class Account que criamos, após isso na mesma linha fizemos o return que retornará essa reposta da entidade e nessa respota iremos persistir os dados no repository chamando o mesmo ali no ".save". Criamos então com a anotação @GetMapping o read onde retornamos a função findAll como parametro do ResponseEntity.
No controller vamo fazer o update e para isso vamos usar a notation @PutMapping com o document como parametro da notation e iniciamos a fun update recebendo um parametro pela url/path e falamos isso com a notation @PathVariable e colocando que será o ducumento do tipo String esse parametro que virá pelo path e após esse parametro falamos que será passado um body tmb para atualizar e falamos isso novamente com a notation @RequestBody e falamos que esperamos uma accout do tipo Account e por fim falamos que o return dessa função de update será um ResponseEntity do tipo <Account>. No corpo da função começamos procurando saber se o que vamos atualizar existe no BD, para saber disso nos usamos a função criada findByDocument que está no repository, então em uma variavel chamamos o findByDocument com document como parametro. Falamos que se ele não encontrar nada com esse document ele retornará uma exception, criamos isso com o .orElseThrow(exception) e nós jogamos isso numa variavel também, então agora essa variavel possui os dados da conta se ela foi encontrada. Após isso nos vamos salvar os novos dados usando a val repository .save, daí fazemos uma copia dessa conta encontrada e trocamos os valores novos pelos antigos, no caso trocamos os name e o balance da account e salvamos em uma nova variavel. Por fim retornamos a responseEntity com status ok e a variavel de update como parametro